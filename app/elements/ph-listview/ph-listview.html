<link rel="import" href="../../../bower_components/core-ajax/core-ajax.html">
<link rel="import" href="../../../bower_components/core-list/core-list.html">
<link rel="import" href="../../../bower_components/core-image/core-image.html">
<link rel="import" href="../helpers.html">
<script type="text/javascript" src="../../../bower_components/moment/min/moment.min.js"></script>

<!--
This component requests data from a given feed and lists them in a listview powered by `<core-list>`. You provide a
custom parse function which is used to parse your feed data. This can either be of type xml, json or rss.

Two predefined views are available to choose from: `compact` and `default`. The compact one doesn't include any
image and only shows the title, the date, the category and a link to click on to read more on the destination site. The
default one shows an additional image and the full description.

RSS feeds are per default parseable without the need of providing a custom parse function. If you're providing your
own parse function, you must return an array which aligns with the following format:

    ...
    [{
      title: 'My Title',
      date: '2010-01-01T05:06:07',
      category: 'My Category',
      description: 'A bit more text',
      link: 'http://www.google.com/'
    }]
    ...

Please note: The date must be parseable by the `Moment.js` library.

##### Example 1

    <ph-listview
      id="listView"
      feed="http://gdata.youtube.com/feeds/api/videos/"
      handleAs="xml"
      viewType="compact"
      sortByDateAsc="false"
    ></ph-listview>

    // NOTE: Provide a JavaScript function to parse custom xml (see below)

##### Example 2

    <ph-listview
      id="listView"
      feed="http://gdata.youtube.com/feeds/api/videos/"
      handleAs="xml"
      viewType="default"
      sortByDateAsc="true"
    ></ph-listview>

    // NOTE: Provide a JavaScript function to parse custom xml (see below)

##### Imperative JavaScript Code for Example 1 + 2

    this.$.listView.setResponseParseFunc(function (response) {
      var xmlNodeTree = response.querySelectorAll('entry'); // we only use the <entry>s

      var entries = [];
      for (var i = 0; i < xmlNodeTree.length; i++) {
        var node = xmlNodeTree[i];
        var media = node.querySelector('group');

        entries.push({
          title: node.querySelector('title').textContent,
          date: node.querySelector('published').textContent,
          link: node.querySelector('link[rel="alternate"]').getAttribute('href'),
          category: media.querySelector('category').getAttribute('label'),
          description: media.querySelector('description').textContent,
          thumb: media.querySelectorAll('thumbnail')[0].getAttribute('url')
        });
      }
      return entries;
    });

##### Example 3

    <ph-listview
      feed="http://www.welt.de/wirtschaft/webwelt/?service=Rss"
      handleAs="rss"
      viewType="default"
      sortByDateAsc="false"
    ></ph-listview>


@group Components Examples
@element ph-listview
@status alpha
@homepage http://silentHoo.github.io/ph-listview
-->
<polymer-element name="ph-listview" constructor="PhListView">
  <template>
    <link rel="stylesheet" href="ph-listview.css">

    <!-- non-visible 3rd party component -->
    <core-ajax id="ajax" auto url="{{ feed }}" on-core-complete="{{ _requestCompleted }}"></core-ajax>

    <!-- template binding to 'default' -->
    <template if="{{ (viewType == 'default' || !viewType) && _entries.length > 0 }}" ref="template-default"></template>

    <!-- template binding to 'compact' -->
    <template if="{{ viewType == 'compact' && _entries.length > 0 }}" ref="template-compact"></template>

    <!-- template definition for 'default' -->
    <template id="template-default">
      <!-- make sure you are 'fit' the given space! -->
      <core-list data="{{ _entries | _filterSortEntries }}" fit>
        <template>
          <div class="view-default" horizontal layout>
            <div class="preview" vertical layout start one>
              <core-image src="{{ model.thumb }}" sizing="contain"></core-image>
            </div>
            <div class="content" flex>
              <div vertical layout>
                <div class="title">{{ model.title }}</div>
                <div class="subtitle"><span class="date">{{ model.date | _filterDateView }}</span>, <span class="category">{{ model.category }}</span></div>
                <div class="description">{{ model.description }}</div>
                <div class="link"><a href="{{ model.link }}">Weiterlesen...</a></div>
              </div>
            </div>
          </div>
        </template>
      </core-list>
    </template>

    <!-- template definition for 'compact' -->
    <template id="template-compact">
      <!-- make sure you are 'fit' the given space! -->
      <core-list data="{{ _entries | _filterSortEntries }}" fit>
        <template>
          <div class="view-default" horizontal layout>
            <div class="content" flex>
              <div vertical layout>
                <div class="title"><a href="{{ model.link }}">{{ model.title }}</a></div>
                <div class="subtitle"><span class="date">{{ model.date | _filterDateView }}</span>, <span class="category">{{ model.category }}</span></div>
              </div>
            </div>
          </div>
        </template>
      </core-list>
    </template>

  </template>

  <script>
    Polymer(Polymer.mixin({ // Mixins @see https://www.polymer-project.org/0.5/docs/polymer/helpers.html#using-mixins

      // published properties of the custom element
      // @see https://www.polymer-project.org/0.5/docs/polymer/polymer.html#published-properties
      publish: {
        /**
         * The `feed` attribute sets the json or xml format list which is requested via XMLHTTPRequest
         * from the remote server.
         *
         * @attribute feed
         * @type string
         * @default ''
         */
        feed: '',

        /**
         * The `handleAs` attribute sets the format for the given feed. Valid inputs are **xml**, **json** and **xml**.
         *
         * @attribute handleAs
         * @type string
         * @default 'rss'
         */
        handleAs: 'xml',

        /**
         * The `viewType` attribute sets the used view which is represented by the component. You can choose between
         * **''** (empty string, which is the same as **'default'**) or **'compact'**. **'default'** shows you a title,
         * date, category, description and an image. A link to the full article/video/whatever is linked too.
         * **'compact'** doesn't show an image and the description.
         *
         * @attribute viewType
         * @type string
         * @default 'default'
         */
        viewType: {
          value: 'default',
          reflect: true // will be reflected to the custom elements attribute value if the viewType's value changes
        },

        /**
         * The `sortByDateAsc` attribute specifies whether the entries should be sorted ascending or descending
         * by their given date. **true** means the oldest entry is on top of the list, **false** vice versa.
         *
         * @attribute sortByDateAsc
         * @type boolean
         * @default false
         */
        sortByDateAsc: false,

        /**
         * The `dateFormat` attribute is used to set your own dateFormat which will be parsed by `Moment.js`. See
         * http://momentjs.com/docs/#/parsing/string-format/ for all formats.
         *
         * @attribute dateFormat
         * @type string
         * @default ''
         */
        dateFormat: ''
      },

      // *** private attributes ***
      _sortAsc: false,  // internal flag indicating the sort order

      // *** lifecycle callbacks ***
      // @see https://www.polymer-project.org/0.5/docs/polymer/polymer.html#lifecyclemethods

      ready: function() {
        // initialize private variables only here and not on the prototype itself to prevent from
        // getting a weird shared state across multiple instances of this component
        this._responseParseFunc = null;
      },

      domReady: function() {
        this._init();
      },

      // *** event delegates ***
      // @see https://www.polymer-project.org/0.5/docs/polymer/polymer.html#imperative-event-mapping
      /*eventDelegates: {
        'response-proceeded': function(event, detail, sender) {
          console.info('The host element (ph-listview) sent a `response-proceeded` event to the outer world with ' +
            'msg: "' + detail.msg + '"');
        }
      },*/

      /**
       * This function sets the custom function defined by the consumer to parse the xml or json document
       * properly. This function *must* return an array in the following structure:
       *
       *     ...
       *     [{
       *       title: 'My Title',
       *       date: '2010-01-01T05:06:07',
       *       category: 'My Category',
       *       description: 'A bit more text',
       *       link: 'http://www.google.com/'
       *     }]
       *     ...
       *
       * @method setResponseParseFunc
       * @param func the function which parses the response
       */
      setResponseParseFunc: function(func) {
        this._responseParseFunc = func;
      },

      // callback handler, @see https://www.polymer-project.org/0.5/docs/polymer/polymer.html#declarative-event-mapping
      _requestCompleted: function(event, detail, sender) {
        if (detail.response != 200) {
          console.warn('The request to the given URL returns error code "' + detail.response + '". Please check the URL.');
          return;
        }
        this._init();

        var response;
        switch (this.handleAs) {
          case 'xml':
          case 'rss':
            response = detail.xhr.responseXML;
            break;
          case 'json':
            response = detail.xhr.response;
            break;
        }
        this._proceedResponse(response);
      },

      // we cannot rerender the current shown list, so we must set the entries to an empty array to take effect
      _resortEntries: function() {
        var tmp = this._entries;
        this._entries = [];
        this.job('a bit hackish', function() {
          this._entries = tmp;
        });
      },

      // *** private methods ***

      _init: function() {
        this._entries = [];

        // check if all is alright
        if (this.feed === '') {
          console.warn('The current URL is empty, please specify one, that I can make a request ;)');
        }

        if (this.handleAs !== 'json' && this.handleAs !== 'rss' && this.handleAs !== 'xml') {
          console.warn('You must set the response type (attribute handleAs) of the given URL to proceed. ' +
            'Please specify json, rss or xml.');
        }

        if (this.viewType !== 'compact' && this.viewType !== 'default' && this.viewType !== '') {
          console.warn('You have not set a viewType. Please use compact or default or keep it empty.');
        }
      },

      // processes the response from the core-ajax component
      _proceedResponse: function(response) {
        if (this.handleAs == 'rss') {
          // we can only handle rss by default, other formats must be provided by the pase/mapping function
          this.setResponseParseFunc(this._rssParseFunc);
        }
        this._entries = this._responseParseFunc(response);
        this.fire('response-proceeded', { msg: 'The response was successfully proceeded' });
      },

      // *** changed watchers ***
      sortByDateAscChanged: function(oldVal, newVal) {
        this._sortAsc = (newVal === 'true' || newVal === true);
      },

      // only resort when the sort direction has changed
      _sortAscChanged: function(oldVal, newVal) {
        this._resortEntries();
      },

      // *** filter methods ***

      _filterSortEntries: function(entries) {
        var me = this;
        entries.sort(function(a, b) {
          var asc = me._sortAsc;
          var aC = asc ? moment(a.date) : moment(b.date);
          var bC = asc ? moment(b.date) : moment(a.date);

          if (aC.isBefore(bC)) {
            return -1;
          } else if (aC.isAfter(bC)) {
            return 1;
          }
          return 0;
        });
        return entries;
      },

      _filterDateView: function(date) {
        var date = this.dateFormat ? moment(date, this.dateFormat) : moment(date);
        return date.format('DD.MM.YYYY - H:mm');
      }
    }, Polymer.MyHelper));
  </script>
</polymer-element>
